
# Python version we're using to run tests.
python -V
Python 2.7.8

# start, stop, and status on a long-lived process
procdog status long
stopped

procdog start long --command "sleep 5"
procdog: debug: client: wait: checking for connect...
procdog: debug: monitor: starting: sleep 5
procdog: debug: monitor: listening on /var/tmp/procdog.long.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
running, pid=_PID_
sleep 2

procdog status long
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
running, pid=_PID_

procdog start long --command "sleep 5"
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
running, pid=_PID_

procdog start long --command "sleep 5" --strict || expect_error
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
procdog: error: process 'long' is already running
(got expected error: status 2)

procdog stop long
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: debug: monitor: process done (code -15), exiting
procdog: debug: monitor: command 'stop': response 'killed'
procdog: debug: client: stop: killed
killed

procdog stop long
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: debug: monitor: command 'stop': response 'exited, code=0'
procdog: debug: client: stop: exited, code=0
exited, code=0

procdog stop long --strict || expect_error
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: debug: monitor: command 'stop': response 'exited, code=0'
procdog: debug: client: stop: exited, code=0
exited, code=0
sleep 4

# start, stop, and status on a short-lived process
procdog status short
stopped

procdog start short --command "sleep 1"
procdog: debug: client: wait: checking for connect...
procdog: debug: monitor: starting: sleep 1
procdog: debug: monitor: listening on /var/tmp/procdog.short.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
running, pid=_PID_
sleep 2
procdog: debug: monitor: process done (code 0), exiting

procdog status short
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'exited, code=0'
procdog: debug: client: status: exited, code=0
exited, code=0

procdog start short --command "sleep 1" --strict
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'exited, code=0'
procdog: debug: client: status: exited, code=0
procdog: debug: client: wait: checking for connect...
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: starting: sleep 1
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'exited, code=0'
procdog: debug: client: status: exited, code=0
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'exited, code=0'
procdog: debug: client: status: exited, code=0
procdog: debug: monitor: listening on /var/tmp/procdog.short.sock
exited, code=0

procdog stop long
stopped

procdog stop long --strict || expect_error
procdog: error: process 'long' is not running
(got expected error: status 3)

# short-lived processes and error conditions
procdog start err1 --command "no-such-command"
procdog: debug: client: wait: checking for connect...
procdog: debug: monitor: starting: no-such-command
procdog: debug: monitor: Failed to start: [Errno 2] No such file or directory: no-such-command
procdog: debug: monitor: listening on /var/tmp/procdog.err1.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: client: status: error: Failed to start: [Errno 2] No such file or directory: no-such-command
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: client: status: error: Failed to start: [Errno 2] No such file or directory: no-such-command
error: Failed to start: [Errno 2] No such file or directory: no-such-command

procdog start err2 --command "false"
procdog: debug: client: wait: checking for connect...
procdog: debug: monitor: starting: false
procdog: debug: monitor: listening on /var/tmp/procdog.err2.sock
procdog: debug: monitor: process done (code 1), exiting
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'exited, code=1'
procdog: debug: client: status: exited, code=1
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: command 'status': response 'exited, code=1'
procdog: debug: client: status: exited, code=1
exited, code=1
sleep 1
procdog: debug: monitor: process done (code 0), exiting
