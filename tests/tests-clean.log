
# Python version we're using to run tests.
python -V
Python 2.7.9

# Error invocations.
procdog blah || expect_error
usage: procdog [-h] [-v] [-c COMMAND] [--health-command HEALTH_COMMAND]
               [--health-count HEALTH_COUNT] [--health-delay HEALTH_DELAY]
               [--ensure-healthy] [--dir DIR] [--stdin STDIN]
               [--stdout STDOUT] [--stderr STDERR] [--append]
               [--linger LINGER] [--strict] [--config CONFIG] [--debug]
               {start,status,wait,stop} id
procdog: error: argument control_cmd: invalid choice: 'blah' (choose from 'start', 'status', 'wait', 'stop')
(got expected error: status 2)

procdog status || expect_error
usage: procdog [-h] [-v] [-c COMMAND] [--health-command HEALTH_COMMAND]
               [--health-count HEALTH_COUNT] [--health-delay HEALTH_DELAY]
               [--ensure-healthy] [--dir DIR] [--stdin STDIN]
               [--stdout STDOUT] [--stderr STDERR] [--append]
               [--linger LINGER] [--strict] [--config CONFIG] [--debug]
               {start,status,wait,stop} id
procdog: error: too few arguments
(got expected error: status 2)

procdog status foo@bar || expect_error
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
usage: procdog [-h] [-v] [-c COMMAND] [--health-command HEALTH_COMMAND]
               [--health-count HEALTH_COUNT] [--health-delay HEALTH_DELAY]
               [--ensure-healthy] [--dir DIR] [--stdin STDIN]
               [--stdout STDOUT] [--stderr STDERR] [--append]
               [--linger LINGER] [--strict] [--config CONFIG] [--debug]
               {start,status,wait,stop} id
procdog: error: Invalid process identifier 'foo@bar'; must be alphanumeric, with only underscores or dashes
(got expected error: status 2)

# Start, stop, and status on a long-lived process.
procdog status long
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
stopped

procdog wait long
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
stopped

procdog start long --command "sleep 5" --health-command "true"
procdog: debug: command-line options: {'command': 'sleep 5', 'health_command': 'true'}
procdog: debug: combined options: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: sleep 5
procdog: monitor: listening on /var/tmp/procdog.long.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check: result: 0
procdog: monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog: debug: client: status: running, health=0, pid=_PID_
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check: result: 0
procdog: monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog: debug: client: status: running, health=0, pid=_PID_
running, health=0, pid=_PID_
sleep 2

procdog status long
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check: result: 0
procdog: monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog: debug: client: status: running, health=0, pid=_PID_
running, health=0, pid=_PID_

procdog wait long
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'wait'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check 0: result: 0
procdog: monitor: command 'wait': response 'running, health=0, pid=_PID_'
procdog: debug: client: wait: running, health=0, pid=_PID_
running, health=0, pid=_PID_

procdog start long --command "sleep 5" --health-command "true"
procdog: debug: command-line options: {'command': 'sleep 5', 'health_command': 'true'}
procdog: debug: combined options: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check: result: 0
procdog: monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog: debug: client: status: running, health=0, pid=_PID_
running, health=0, pid=_PID_

procdog start long --command "sleep 5" --health-command "true" --strict || expect_error
procdog: debug: command-line options: {'strict': True, 'command': 'sleep 5', 'health_command': 'true'}
procdog: debug: combined options: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check: result: 0
procdog: monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog: debug: client: status: running, health=0, pid=_PID_
procdog: error: process 'long' is already running
(got expected error: status 2)

procdog stop long
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: monitor: process done (code -15), exiting
procdog: monitor: command 'stop': response 'killed, signal=15'
procdog: debug: client: stop: killed, signal=15
killed, signal=15

procdog stop long
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: monitor: command 'stop': response 'exited, returncode=-15'
procdog: debug: client: stop: exited, returncode=-15
exited, returncode=-15

procdog stop long --strict || expect_error
procdog: debug: command-line options: {'strict': True}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: monitor: command 'stop': response 'exited, returncode=-15'
procdog: debug: client: stop: exited, returncode=-15
exited, returncode=-15
sleep 4

# Start, stop, and status on a short-lived process.
procdog status short
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
stopped

procdog start short --command "sleep 1"
procdog: debug: command-line options: {'command': 'sleep 1'}
procdog: debug: combined options: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: sleep 1
procdog: monitor: listening on /var/tmp/procdog.short.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'running, pid=_PID_'
procdog: debug: client: status: running, pid=_PID_
running, pid=_PID_
sleep 2
procdog: monitor: process done (code 0), exiting

procdog status short
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
exited, returncode=0

procdog start short --command "sleep 1" --strict
procdog: debug: command-line options: {'strict': True, 'command': 'sleep 1'}
procdog: debug: combined options: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: debug: client: wait: checking for connect...
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: monitor: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True)
procdog: monitor: starting shell command: sleep 1
procdog: monitor: listening on /var/tmp/procdog.short.sock
exited, returncode=0

procdog stop long
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
stopped

procdog stop long --strict || expect_error
procdog: debug: command-line options: {'strict': True}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True)
procdog: error: process 'long' is not running
(got expected error: status 3)

# A long-lived unhealthy process.
procdog wait unhealthy1
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
stopped

procdog start unhealthy1 --command "sleep 100" --health-command "false"
procdog: debug: command-line options: {'command': 'sleep 100', 'health_command': 'false'}
procdog: debug: combined options: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: sleep 100
procdog: monitor: listening on /var/tmp/procdog.unhealthy1.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check: result: 1
procdog: monitor: command 'status': response 'running, health=1, pid=_PID_'
procdog: debug: client: status: running, health=1, pid=_PID_
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check: result: 1
procdog: monitor: command 'status': response 'running, health=1, pid=_PID_'
procdog: debug: client: status: running, health=1, pid=_PID_
running, health=1, pid=_PID_

procdog wait unhealthy1
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'wait'
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 0: result: 1
procdog: monitor: process done (code 0), exiting
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 1: result: 1
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 2: result: 1
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 3: result: 1
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 4: result: 1
procdog: monitor: command 'wait': response 'running, health=1, pid=_PID_'
procdog: debug: client: wait: running, health=1, pid=_PID_
running, health=1, pid=_PID_

procdog stop unhealthy1
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: monitor: process done (code -15), exiting
procdog: monitor: command 'stop': response 'killed, signal=15'
procdog: debug: client: stop: killed, signal=15
killed, signal=15

# Test --ensure-healthy.
procdog start ensure1 --command "sleep 100" --health-command "true" --ensure-healthy
procdog: debug: command-line options: {'ensure_healthy': True, 'command': 'sleep 100', 'health_command': 'true'}
procdog: debug: combined options: Options(command='sleep 100', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='sleep 100', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=True, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: sleep 100
procdog: monitor: listening on /var/tmp/procdog.ensure1.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check: result: 0
procdog: monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog: debug: client: status: running, health=0, pid=_PID_
procdog: debug: client: wait: connect success
procdog: debug: monitor: ensure_healthy is set, waiting for health
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'wait'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check 0: result: 0
procdog: monitor: command 'wait': response 'running, health=0, pid=_PID_'
procdog: debug: client: wait: running, health=0, pid=_PID_
procdog: debug: monitor: ensure_healthy is set and process is still healthy (running, health=0, pid=_PID_)
running, health=0, pid=_PID_

procdog stop ensure1
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: monitor: process done (code -15), exiting
procdog: monitor: command 'stop': response 'killed, signal=15'
procdog: debug: client: stop: killed, signal=15
killed, signal=15

procdog start ensure2 --command "sleep 100" --health-command "false" --ensure-healthy
procdog: debug: command-line options: {'ensure_healthy': True, 'command': 'sleep 100', 'health_command': 'false'}
procdog: debug: combined options: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=True, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: sleep 100
procdog: monitor: listening on /var/tmp/procdog.ensure2.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check: result: 1
procdog: monitor: command 'status': response 'running, health=1, pid=_PID_'
procdog: debug: client: status: running, health=1, pid=_PID_
procdog: debug: client: wait: connect success
procdog: debug: monitor: ensure_healthy is set, waiting for health
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'wait'
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 0: result: 1
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 1: result: 1
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 2: result: 1
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 3: result: 1
procdog: debug: monitor: running health check: command: false
procdog: debug: monitor: health check 4: result: 1
procdog: monitor: command 'wait': response 'running, health=1, pid=_PID_'
procdog: debug: client: wait: running, health=1, pid=_PID_
procdog: debug: monitor: ensure_healthy is set and process is still not healthy (running, health=1, pid=_PID_); stopping
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: monitor: process done (code -15), exiting
procdog: monitor: command 'stop': response 'killed, signal=15'
procdog: debug: client: stop: killed, signal=15
killed, signal=15

# Short-lived processes and error conditions.
rm -f tmp.stdout.* tmp.stderr.* tmp.stdin.*

procdog start err1 --command "no-such-command"
procdog: debug: command-line options: {'command': 'no-such-command'}
procdog: debug: combined options: Options(command='no-such-command', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='no-such-command', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: no-such-command
procdog: monitor: Failed to start: [Errno 2] No such file or directory: 'no-such-command': no-such-command
procdog: monitor: listening on /var/tmp/procdog.err1.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: client: status: error: Failed to start: [Errno 2] No such file or directory: 'no-such-command': no-such-command
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: client: status: error: Failed to start: [Errno 2] No such file or directory: 'no-such-command': no-such-command
error: Failed to start: [Errno 2] No such file or directory: 'no-such-command': no-such-command

procdog start err2 --command "false"
procdog: debug: command-line options: {'command': 'false'}
procdog: debug: combined options: Options(command='false', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='false', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: false
procdog: monitor: listening on /var/tmp/procdog.err2.sock
procdog: monitor: process done (code 1), exiting
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=1'
procdog: debug: client: status: exited, returncode=1
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=1'
procdog: debug: client: status: exited, returncode=1
exited, returncode=1

procdog start pwd --command "pwd" --stdout tmp.stdout.pwd
procdog: debug: command-line options: {'command': 'pwd', 'stdout': 'tmp.stdout.pwd'}
procdog: debug: combined options: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: pwd
procdog: monitor: listening on /var/tmp/procdog.pwd.sock
procdog: monitor: process done (code 0), exiting
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
exited, returncode=0
tail -1 tmp.stdout.pwd
/tmp/procdog-tests

procdog start pwd --command "pwd" --stdout tmp.stdout.pwd --dir /tmp
procdog: debug: command-line options: {'command': 'pwd', 'dir': '/tmp', 'stdout': 'tmp.stdout.pwd'}
procdog: debug: combined options: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: debug: client: wait: checking for connect...
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: monitor: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: pwd
procdog: monitor: listening on /var/tmp/procdog.pwd.sock
procdog: monitor: process done (code 0), exiting
exited, returncode=0
tail -1 /tmp/tmp.stdout.pwd
/tmp

# Redirect stdout and stderr. Environment variables.
export TESTENV=wensleydale
procdog start out1 --command 'echo hello $TESTENV' --stdout tmp.stdout.out1 --stderr tmp.stderr.out1
procdog: debug: command-line options: {'command': 'echo hello $TESTENV', 'stderr': 'tmp.stderr.out1', 'stdout': 'tmp.stdout.out1'}
procdog: debug: combined options: Options(command='echo hello $TESTENV', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='echo hello wensleydale', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: echo hello wensleydale
procdog: monitor: listening on /var/tmp/procdog.out1.sock
procdog: monitor: process done (code 0), exiting
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
exited, returncode=0
sleep 1
cat tmp.stdout.out1
procdog: _TIMESTAMP_ Starting process 'out1' with command: echo hello wensleydale
hello wensleydale
cat tmp.stderr.out1
procdog: _TIMESTAMP_ Starting process 'out1' with command: echo hello wensleydale
rm -f tmp.stdout.* tmp.stderr.* tmp.stdin.*

# Read from input and write stderr and stdout to same output.
echo input > tmp.stdin.out2
procdog start out2 --command "cat" --stdin tmp.stdin.out2 --stdout tmp.stdout.out2 --stderr tmp.stdout.out2
procdog: debug: command-line options: {'stdin': 'tmp.stdin.out2', 'command': 'cat', 'stderr': 'tmp.stdout.out2', 'stdout': 'tmp.stdout.out2'}
procdog: debug: combined options: Options(command='cat', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin='tmp.stdin.out2', stdout='tmp.stdout.out2', stderr='tmp.stdout.out2', append=False, linger=3.0, strict=False)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='cat', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin='tmp.stdin.out2', stdout='tmp.stdout.out2', stderr='tmp.stdout.out2', append=False, linger=3.0, strict=False)
procdog: monitor: starting shell command: cat
procdog: monitor: listening on /var/tmp/procdog.out2.sock
procdog: monitor: process done (code 0), exiting
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
procdog: debug: client: wait: connect success
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: monitor: command 'status': response 'exited, returncode=0'
procdog: debug: client: status: exited, returncode=0
exited, returncode=0
cat tmp.stdin.out2
input
cat tmp.stdout.out2
procdog: _TIMESTAMP_ Starting process 'out2' with command: cat
input


# Configuration tests.
procdog start conftest --config $config_file
procdog: debug: config file options from file _PATH_/procdog.cfg: {'health_command': 'true', 'health_delay': 0.5, 'strict': True, 'health_count': 10, 'command': 'sleep 100', 'ensure_healthy': True}
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command='sleep 100', health_command='true', health_count=10, health_delay=0.5, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True)
procdog: debug: client: wait: checking for connect...
procdog: monitor: Options(command='sleep 100', health_command='true', health_count=10, health_delay=0.5, ensure_healthy=True, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True)
procdog: monitor: starting shell command: sleep 100
procdog: monitor: listening on /var/tmp/procdog.conftest.sock
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'status'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check: result: 0
procdog: monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog: debug: client: status: running, health=0, pid=_PID_
procdog: debug: client: wait: connect success
procdog: debug: monitor: ensure_healthy is set, waiting for health
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'wait'
procdog: debug: monitor: running health check: command: true
procdog: debug: monitor: health check 0: result: 0
procdog: monitor: command 'wait': response 'running, health=0, pid=_PID_'
procdog: debug: client: wait: running, health=0, pid=_PID_
procdog: debug: monitor: ensure_healthy is set and process is still healthy (running, health=0, pid=_PID_)
running, health=0, pid=_PID_

procdog stop conftest --config $config_file
procdog: debug: config file options from file _PATH_/procdog.cfg: {'health_command': 'true', 'health_delay': 0.5, 'strict': True, 'health_count': 10, 'command': 'sleep 100', 'ensure_healthy': True}
procdog: debug: command-line options: {}
procdog: debug: combined options: Options(command='sleep 100', health_command='true', health_count=10, health_delay=0.5, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True)
procdog: debug: client: connected
procdog: debug: monitor: listen accept
procdog: debug: monitor: received command 'stop'
procdog: monitor: process done (code -15), exiting
procdog: monitor: command 'stop': response 'killed, signal=15'
procdog: debug: client: stop: killed, signal=15
killed, signal=15

procdog start conftest_bad --config $config_file
procdog: error: Not a boolean: not-valid
