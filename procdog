#!/usr/bin/env python

r'''
Procdog is a simple command-line tool to start, stop, and check the health of
processes.

It is intended to be a very simple and easy-to-use alternative to more
full-featured deployment tools (such as Monit), and to be cross-platform,
unlike traditional OS-specific tools (such as start-stop-daemon and Upstart),
for use in development, in build systems and test harnesses, etc.

It operates by starting a small daemon that popen()s and monitors the process.
The daemon listens and accepts commands on a local Unix domain socket, making
it possible to check the process is running or terminate it, and to do simple
health checks. For simplicity, there is a single Procdog daemon for each
monitored process, so each process is handled completely separately.
'''

# Author: Joshua Levy
# Created: 2015-03-14
# https://github.com/jlevy/procdog

from __future__ import print_function
import socket, sys, os, time, shlex, ConfigParser, argparse, re
from collections import namedtuple
from string import Template
from datetime import datetime
from threading import Thread, Lock
# The subprocess module has known threading issues, so prefer subprocess32.
try:
  import subprocess32 as subprocess
except ImportError:
  import subprocess

NAME = "procdog"
VERSION = "0.1.5"
DESCRIPTION = "procdog: Lightweight command-line process control"

SOCKET_PATH_PAT = "/var/tmp/" + NAME + ".%s.sock"

LOG_PATH_PAT = "/var/tmp/" + NAME + ".%s.log"

CONFIG_FILE = "procdog.cfg"
CONFIG_DOTFILE = "." + CONFIG_FILE

CMD_START = "start"  # Not a command sent to monitor.
CMD_STATUS = "status"
CMD_WAIT = "wait"
CMD_STOP = "stop"

CMD_LIST = [CMD_START, CMD_STATUS, CMD_WAIT, CMD_STOP]

RESP_STOPPED = "stopped"  # Not a command returned from monitor.
RESP_RUNNING = "running"
RESP_KILLED = "killed"
RESP_EXITED = "exited"
RESP_INVALID = "invalid"
RESP_ERROR = "error"

# Return code expected for a valid health check.
HEALTHY_CODE = 0

EOM = "\n"

SOCKET_TIMEOUT = 3

DEBUG = False

LOG_BUFFERING = 1

_UTC_TIMESTAMP = datetime.utcnow().isoformat() + 'Z'

# Workarounds for lack of Python 2 subprocess /dev/null support
_NULL_INPUT = open(os.devnull, "r")
_NULL_OUTPUT = open(os.devnull, "w")

# Lock is only local to process, but still helps serialize multiple monitor thread logs.
_LOG_LOCK = Lock()

def _debug(msg):
  global DEBUG
  if DEBUG:
    with _LOG_LOCK:
      print("%s: debug: %s" % (NAME, msg), file=sys.stderr)

def _info(msg):
  with _LOG_LOCK:
    print("%s: %s" % (NAME, msg), file=sys.stderr)

def _die(msg, code=1):
  print("%s: error: %s" % (NAME, msg), file=sys.stderr)
  sys.exit(code)


class StateException(Exception):
    pass
class NotRunningException(StateException):
    pass
class AlreadyRunningException(StateException):
    pass
class OtherException(StateException):
    pass


def _rm_socket_path(path, silent=False):
  if silent:
    try:
      os.unlink(path)
    except:
      pass
  else:
    try:
      os.unlink(path)
    except OSError:
      if os.path.exists(path):
        raise

def _recv_msg(sock):
  '''Receive a (short) newline-delimited command. Trims whitespace.'''
  data = ""
  while True:
    more_data = sock.recv(1024)
    data += more_data
    if not more_data or more_data.find(EOM) >= 0:
      break
  return data.split(EOM)[0].strip()

def _listen(socket_path, handler):
  '''Listen on Unix domain socket, calling handler() on the received commands and returning
     the results.'''

  sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
  sock.bind(socket_path)
  sock.listen(16)
  _info("monitor: listening on %s" % socket_path)

  while True:
    connection, client_address = sock.accept()
    _debug("monitor: listen accept")
    try:
      cmd = _recv_msg(connection)
      _debug("monitor: received command '%s'" % cmd)
      response = handler(cmd)
      connection.sendall(response + EOM)
    finally:
      connection.close()

# We use a single listening thread (not a pool) since this is thread is only to monitor a single
# process. All request handling, including the wait with health check, should happen serially.
class _ListenThread(Thread):
  def __init__(self, socket_path, handler):
    Thread.__init__(self)
    self.socket_path = socket_path
    self.handler = handler
    # Do not prevent process termination on shutdown.
    self.daemon = True

  def run(self):
    _listen(self.socket_path, self.handler)


def _resp_encode(code, error=None, **kwargs):
  if error:
    return "%s: %s" % (RESP_ERROR, error)
  out = [code] + ["%s=%s" % (k, v) for (k, v) in sorted(kwargs.items()) if v is not None]
  return ", ".join(out)

def _resp_decode(str):
  if str.startswith(RESP_ERROR):
    return str.split(": ")
  else:
    return str.split(", ")

# TODO Encapsulate encoding/decoding as a proper class.
def _resp_is_unhealthy(str):
  bits = _resp_decode(str)
  return bits[0] == RESP_RUNNING and "health=0" not in bits


def _health_check(health_cmd, count=None):
  _debug("monitor: running health check: command: %s" % health_cmd)
  args = shlex.split(health_cmd)
  health = subprocess.call(args, stdin=_NULL_INPUT, stdout=_NULL_OUTPUT, stderr=_NULL_OUTPUT)
  _debug("monitor: health check%s: result: %s" % ("" if count is None else " %s" % count, health))
  return health

def _wait_for_health(popen, options):
  '''Wait for the given process to exit, the health command to return true, or the total health
     checks to expire. Return final health code, or None if process already exited.'''
  health = None
  for count in range(0, options.health_count):
    if popen.poll() is not None:
      return None
    health = _health_check(options.health_command, count=count)
    if health == HEALTHY_CODE:
      return health
    time.sleep(options.health_delay)
  return health


def _handle_command(cmd, popen, options):
  '''Handle the given command and return a result, using the given popen to get info
     about the process.'''
  try:
    health_command = options.health_command
    health_count = options.health_count
    health_delay = options.health_delay
    # Treat an empty command like a status command for convenience. This way you can cat the
    # socket and see status.
    if cmd == "" or cmd == CMD_STATUS:
      health = None
      if health_command:
        health = _health_check(health_command)
      if popen.poll() is None:
        resp = _resp_encode(RESP_RUNNING, pid=popen.pid, health=health)
      else:
        resp = _resp_encode(RESP_EXITED, returncode=popen.returncode, health=health)
    elif cmd == CMD_WAIT:
      if health_command:
        health = _wait_for_health(popen, options)
      if popen.poll() is None:
        resp = _resp_encode(RESP_RUNNING, pid=popen.pid, health=health)
      else:
        resp = _resp_encode(RESP_EXITED, returncode=popen.returncode, health=health)
    elif cmd == CMD_STOP:
      if popen.poll() is None:
          # TODO: Handle additional signals besides 15
          popen.terminate()
          popen.wait()
          resp = _resp_encode(RESP_KILLED, signal=15)
      else:
          resp = _resp_encode(RESP_EXITED, returncode=popen.returncode)
    else:
      resp = _resp_encode(RESP_INVALID)
  except (OSError, IOError) as e:
    _info("exception handling command '%s': %s" % (cmd, e))
    resp = _resp_encode(RESP_ERROR, error=e)

  _info("monitor: command '%s': response '%s'" % (cmd, resp))
  return resp

def _open_logfile(filename, write_mode, id, shell_cmd, write_header=True):
  f = open(filename, write_mode, LOG_BUFFERING)
  if write_header:
    f.write("%s: %s Starting process '%s' with command: %s\n" % (NAME, _UTC_TIMESTAMP, id, shell_cmd))
    f.flush()
  return f


def daemonize(home_dir="/", umask=077, do_redirect=True, stdout=None, stderr=None):
  '''Do a standard double fork to daemonize. Based on portions of
     http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/www.boxedice.com and
     https://github.com/serverdensity/python-daemon'''

  # Do first fork and return control to calling process.
  try:
    pid = os.fork()
    if pid > 0:
      return False
  except OSError, e:
    sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
    sys.exit(1)

  # Decouple from parent environment.
  os.chdir(home_dir)
  os.setsid()
  os.umask(umask)

  # Do second fork.
  try:
    pid = os.fork()
    if pid > 0:
      sys.exit(0)  # Exit second parent.
  except OSError, e:
    sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
    sys.exit(1)

  # Redirect standard file descriptors.
  if do_redirect:
    sys.stdout.flush()
    sys.stderr.flush()

    so = file(stdout, 'a+') if stdout else _NULL_OUTPUT
    se = file(stderr, 'a+', 0) if stderr else so

    os.dup2(_NULL_INPUT.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

  # TODO: Change from Python signal handler?
  return True

def daemonize_and_monitor(id, shell_cmd, options):
  '''Start a monitor daemon that forks the given shell command, listens, and handles commands via a
     control socket.'''

  # Deamonize. If we're debugging, keep all debug output on the console.
  is_daemon = daemonize(home_dir=options.dir, do_redirect=not DEBUG, stdout=LOG_PATH_PAT % id)

  if is_daemon:
    _info("monitor: %s" % (options,))
    _info("monitor: starting shell command: %s" % shell_cmd)
    popen = None
    error = None

    # Open file descriptors for stdout/stderr if needed. We always set stdin to /dev/null.
    # TODO: Consider closing of these on process exit.
    write_mode = 'a' if options.append else 'w'
    fin = _NULL_INPUT
    fout = None
    ferr = None
    # Note paths here are relative to options.dir.
    if options.stdin:
      fin = open(options.stdin, 'r')
    if options.stdout:
      fout = _open_logfile(options.stdout, write_mode, id, shell_cmd, write_header=True)
    if options.stderr:
      if options.stderr == options.stdout:
        ferr = fout
      else:
        ferr = _open_logfile(options.stderr, write_mode, id, shell_cmd, write_header=True)

    # Start process, tracking any immediate errors.
    try:
      args = shlex.split(shell_cmd)
      popen = subprocess.Popen(args, stdin=fin, stdout=fout, stderr=ferr)
    except OSError as e:
      error = "Failed to start: %s: %s" % (e, shell_cmd)
      _info("monitor: %s" % error)
    if popen and popen.poll() is not None:
      error = "Failure starting (code %s): %s" % (popen.poll(), shell_cmd)
      _info("monitor: %s" % error)

    # Start listener on fresh Unix domain socket
    socket_path = SOCKET_PATH_PAT % id
    _rm_socket_path(socket_path, silent=False)

    # If there was an error starting the process, communicate that to original client.
    if popen:
      handler = lambda cmd: _handle_command(cmd, popen, options)
    else:
      handler = lambda cmd: _resp_encode(RESP_ERROR, error=error)

    listen_thread = _ListenThread(socket_path, handler)
    listen_thread.start()

    if popen:
      exit_code = popen.wait()
      _info("monitor: process done (code %s), exiting" % exit_code)

    time.sleep(options.linger)
    # Just for cleanliness, best effort at removing the path when we're done; though if it remains
    # there we will just remove and re-bind on next startup.
    _rm_socket_path(socket_path, silent=True)
    sys.exit(0)

  else:
    _wait_for_connect(id)


def send_command(id, cmd):
  '''Send a command to the monitor process with the given id via its control socket.'''

  sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
  try:
    # Set a short timeout on connect, in case process not running. Once we connect, disable the timeout.
    sock.settimeout(SOCKET_TIMEOUT)
    sock.connect(SOCKET_PATH_PAT % id)
    sock.settimeout(None)
    _debug("client: connected")
    sock.sendall(cmd + EOM)
    data = _recv_msg(sock)
    if not data:
      # A rare race or a bug.
      raise NotRunningException("no data from monitor")
    _debug("client: %s: %s" % (cmd, data))
    return data
  except socket.error as msg:
    raise NotRunningException("socket error: %s" % msg)
  finally:
    sock.close()

def _wait_for_connect(id):
  _debug("client: wait: checking for connect...")
  timeout = time.time() + SOCKET_TIMEOUT
  exc = None
  while time.time() < timeout:
    try:
      status = send_command(id, CMD_STATUS)
      _debug("client: wait: connect success")
      return
    except NotRunningException as e:
      exc = e
      time.sleep(.1)
  raise OtherException("Timeout connecting to monitor: %s" % exc)


def start(id, shell_cmd, options, strict=False):
  '''Start a process, assigning it the given id. If strict is true, return existing process status;
     otherwise raise exception if process already is running.'''
  prev_status = status(id)
  prev_code = _resp_decode(prev_status)[0]
  if prev_code in [RESP_STOPPED, RESP_EXITED, RESP_KILLED]:
    daemonize_and_monitor(id, shell_cmd, options)
    if options.ensure_healthy:
      _debug("monitor: ensure_healthy is set, waiting for health")
      resp = send_command(id, CMD_WAIT)
      # TODO: Replace with proper response parsing.
      if _resp_is_unhealthy(resp):
        _debug("monitor: ensure_healthy is set and process is still not healthy (%s); stopping" % resp)
        resp = send_command(id, CMD_STOP)
      else:
        _debug("monitor: ensure_healthy is set and process is still healthy (%s)" % resp)
    else:
      resp = send_command(id, CMD_STATUS)
  else:
    if strict:
      raise AlreadyRunningException("Process already running (%s)" % prev_status)
    else:
      resp = prev_status
  return resp

def status(id):
  '''Return status of the process with the given id.'''
  try:
    return send_command(id, CMD_STATUS)
  except NotRunningException:
    return RESP_STOPPED

def wait(id):
  '''Same as status, but if process is running, try to wait until it is healthy.'''
  try:
    return send_command(id, CMD_WAIT)
  except NotRunningException:
    return RESP_STOPPED

def stop(id, strict=False):
  '''Stop the command with the given id. If strict is true, raise exception if process already is stopped.'''
  try:
    return send_command(id, CMD_STOP)
  except NotRunningException as e:
    if strict:
      raise
    else:
      return RESP_STOPPED


def _locate_config_file():
  '''Look in common locations for config file.'''
  base_dir = os.path.dirname(sys.argv[0])
  paths = [os.path.join(base_dir, CONFIG_FILE), os.path.join(os.getenv("HOME"), CONFIG_DOTFILE)]
  for path in paths:
    if os.path.isfile(path):
      _debug("using config file: %s" % path)
      return path
  return None

def _parse_config(config, section, option, target_type):
  if target_type == str:
    return config.get(section, option)
  elif target_type == bool:
    return config.getboolean(section, option)
  elif target_type == int:
    return config.getint(section, option)
  elif target_type == float:
    return config.getfloat(section, option)

def _read_config_file(id, config_file, target_types):
  out = {}
  try:
    if config_file:
      config = ConfigParser.RawConfigParser()
      config.read(config_file)
      for (key, str_value) in config.items(id):
        if key not in Options._fields:
          raise ValueError("Unrecognized config key: '%s' in '%s'" % (key, config_file))
        out[key] = _parse_config(config, id, key, target_types[key])
  except ConfigParser.NoSectionError:
    pass
  return out

def _expand_variables(template_str):
  '''Expand a string like "$HOME/foo" using environment variables.'''
  if template_str is None:
    return None
  else:
    return Template(template_str).substitute(os.environ)

# These are the options configurable by file or command line.
Options = namedtuple("Options", "command health_command health_count health_delay ensure_healthy dir stdin stdout stderr append linger strict")

OPTION_DEFAULTS = Options(command=None, health_command=None, health_count=5, health_delay=1., ensure_healthy=False,
                          dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3., strict=False)

def main():
  parser = argparse.ArgumentParser(description=DESCRIPTION, version=VERSION, epilog="\n" + __doc__)
  parser.add_argument("control_cmd", help="command", choices=CMD_LIST)
  parser.add_argument("id", help="unique identifier for this process")
  parser.add_argument("-c", "--command", help="with start: full command to start process, with all arguments, in shell syntax")
  parser.add_argument("--health-command", help="with start: full command to perform health check")
  parser.add_argument("--health-count", help="with start: max tries for health check", type=int)
  parser.add_argument("--health-delay", help="with start: delays for health check", type=float)
  parser.add_argument("--ensure-healthy", help="with start: wait for health, then shut down if not healhty", action="store_true")
  parser.add_argument("--dir", help="with start: alternate directory to start from")
  parser.add_argument("--stdin", help="with start: filename for standard input (defaults to /dev/null)")
  parser.add_argument("--stdout", help="with start: filename for standard input")
  parser.add_argument("--stderr", help="with start: filename for standard error (may be same as --stdout)")
  parser.add_argument("--append", help="with start: append to files specified in --stdout and --stderr", action="store_true")
  parser.add_argument("--linger", help="with start: seconds for monitor to linger, preserving exit code", type=float)
  parser.add_argument("--strict", help="abort with error if asked to start a started process or stop a stopped one", action="store_true")
  parser.add_argument("--config", help="non-default location on config file to read")
  parser.add_argument("--debug", help="enable debugging output", action="store_true")
  args = parser.parse_args()

  global DEBUG
  DEBUG = args.debug

  try:
    config_file = args.config if args.config else _locate_config_file()

    # XXX Hack to reuse argparse's internal actions list, to avoid repeating ourselves when parsing out data types from the config file.
    actions = { action.dest: action for action in parser._actions if action.dest in Options._fields }
    target_types = { action.dest: (action.type or type(action.const or "")) for action in actions.values() }

    file_options = _read_config_file(args.id, config_file, target_types)

    def was_explicitly_set(action, val):
      return (type(action) != argparse._StoreTrueAction and type(action) != argparse._StoreFalseAction) or val != action.default

    # These are only the options that were explicitly set.
    command_line_options = { key: val for (key, val) in vars(args).items()
                                                     if key in Options._fields and val is not None and was_explicitly_set(actions[key], val) }

    # Precedence on options is command line, then file, then defaults.
    default_options = vars(OPTION_DEFAULTS)

    combined = default_options.copy()
    combined.update(file_options)
    combined.update(command_line_options)
    options = Options(**combined)

    if config_file:
      _debug("config file options from file %s: %s" % (config_file, file_options))
    _debug("command-line options: %s" % command_line_options)
    _debug("combined options: %s" % (options,))

    # Final preparation of options.
    # Expand environment variables now, while they are available.
    options = options._replace(command=_expand_variables(options.command),
                               health_command=_expand_variables(options.health_command),
                               dir=_expand_variables(options.dir) or os.getcwd())

    if not re.compile("^[\\w-]+$").match(args.id):
      parser.error("Invalid process identifier '%s'; must be alphanumeric, with only underscores or dashes" % args.id)
    if args.control_cmd == "start" and not options.command:
      parser.error("Must specify --command with 'start' or supply a command in the config file for this id ('%s')" % args.id)
    if not os.path.isdir(options.dir):
      parser.error("Not a directory: %s" % options.dir)

    if args.control_cmd == CMD_START:
      result = start(args.id, options.command, options=options, strict=options.strict)
    elif args.control_cmd == CMD_STOP:
      result = stop(args.id, strict=options.strict)
    elif args.control_cmd == CMD_STATUS:
      result = status(args.id)
    elif args.control_cmd == CMD_WAIT:
      result = wait(args.id)
    print(result)

  except AlreadyRunningException as e:
    _die("process '%s' is already running" % args.id, code=2)
  except NotRunningException as e:
    _die("process '%s' is not running" % args.id, code=3)
  except ValueError as e:
    _die(str(e), code=4)

if __name__ == '__main__':
  main()

# TODO:
# - return health code as exit code on wait
# - on Linux, exit code doesn't show kill signal (-15): stop gives 'exited, returncode=0' vs 'exited, returncode=-15'
# - kill -15 followed by kill -9 if no response; custom kill signals
# - --shell option that invokes full shell parsing of command and health_command
# - list command to show status of all running processes
# - customizable shutdown command (e.g. another script to execute that does something besides just kill)
# - restart (kill + start) command
# - retry policies to rerun if process dies
# - tests for more corner cases such as shlex failures and config file errors
# - more testing on Mac+Linux
# - keyboard interrupt handler with best effort to kill process if user does control-C while health check is waiting?
